---
title: "ggplot summer workshop"
author: "Paul A. Bloom"
date: "June 26, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(ggplot2)
require(lme4)
require(rstanarm)
require(rstantools)
require(brms)
require(merTools)
```


```{r}
n_subjs = 20
n_obs_per_subj = 10
raw_data <- tibble(id = 1:n_subjs,
				   intercept = rnorm(n_subjs)) %>%
slice(rep(1:n(), each = n_obs_per_subj)) %>%
mutate(slope = 1, # or whatever you want
	   x = rnorm(n()),
	   y = intercept + slope*x + rnorm(n()))

model <- lmer(y ~ x + (1 | id), data = raw_data)

n_iterations <- 10

a <- (boots$raw_data)[[1]]$data

boots <- raw_data %>%
group_by(id) %>%
nest() %>%
nest(.key = "raw_data") %>%
mutate(boots = map(raw_data, ~rerun(n_iterations, tibble(data = sample(.x$data, size = length(.x$data), replace = T)) %>%
									mutate(id_boot = 1:nrow(.)) %>%
									unnest()) %>%
                        tibble(data = .)),
         boots = map(boots, ~.x %>%
                       mutate(model = map(data, function(x) {
                         y <- lmer(y ~ x + (1 | id_boot),
                                    data = x) %>%
                           broom::tidy() %>%
                           as_tibble()
                         cat(".poke")
                         return (y)
                         })) %>%
                       select(-data))) %>%
  select(boots) %>%
  unnest() %>%
  mutate(iteration = 1:n()) %>%
  unnest(model)


```

```{r}
n <- 100
subject <- seq(1:n)
time <- 0:10
group <- rbinom(n, 1, .5)
grid <- data.frame(expand.grid(subject = subject, time= time))
multi <- data.frame(cbind(subject, group)) %>%
  dplyr::left_join(., grid, by = 'subject')


# Simulation params
groupIntercept <- 50
sdIntercept <- 10
grouptimeBeta <- 4
sdtimeBeta <- 2
withinSd <- 1


# generate an intercept + slope for each subject
multi_subs <- multi %>% 
  group_by(subject) %>%
  summarise(subIntercept = rnorm(1, groupIntercept, sdIntercept), 
              subSlope = rnorm(1, grouptimeBeta, sdtimeBeta))
  
  # join intercepts to main frame
  multi <- left_join(multi, multi_subs)

  # get values for each subject
  multi <- dplyr::mutate(multi, 
                         outcome = subIntercept + time*subSlope  + 
                           rnorm(nrow(multi), 0, withinSd) + rnorm(nrow(multi), group*20, 5), # adding a quick group effect here
                         group = as.factor(group))

theme_set(theme_bw())
ggplot(multi, aes(x = time, y = outcome, color = group)) +
  geom_jitter(height = 0, width = .2, alpha = .5, size = 2) +
  geom_line(aes(group = subject))

```


```{r}
mod_rstanarm <- stan_glmer(data = multi, outcome ~ time*group + (1|subject))
mod_lme4 <- lmer(data = multi, outcome ~ time*group + (1|subject))
mod_brms <- brm(data = multi, outcome ~ time*group + (1|subject))
summary(mod_brms)


marginal_effects(mod_brms, surface = FALSE, probs = c(0.025, 0.975), re_formula = NULL, method = 'predict')


```
Bootstrapping function
```{r}
strapMyBoots <- function(data, model){
  
  
}

newx<- expand.grid(time = 0:10, group = factor(0:1))


n <- 500
sampsOutFrame <- matrix(nrow = n, ncol = nrow(newx))
for(ii in 1:n){
  #iboot <- sample(1:nrow(multi), replace = TRUE)
  #bootdata <- multi[iboot,]
  bootsubs <- sample(unique(multi$subject), replace = TRUE)
  bootdata <- multi %>%
    subset(is.na(subject))
  for(jj in 1:length(bootsubs)){
    subjectData <- subset(multi, subject == bootsubs[jj]) %>%
      mutate(subject == jj)
    bootdata <- rbind(bootdata, subjectData)
  }
  mod_sample <- lmer(data = bootdata, outcome ~ time + group + (1|subject))
  sampsOutFrame[ii,] <- predict(mod_sample, newdata = newx, re.form = NA) 
  cat('.')
}

means <- (t(summarise_all(as.data.frame(sampsOutFrame), .funs = mean)))
lwr <- t(summarise_all(as.data.frame(sampsOutFrame), .funs = quantile, probs = .025))
upr <- t(summarise_all(as.data.frame(sampsOutFrame), .funs = quantile, probs = .975))
lme_predictions <- data.frame(cbind(means, lwr, upr))

names(lme_predictions) <- c('fit', 'upr', 'lwr')

```


```{r}
# Generate a 'grid' of new data values
newx<- expand.grid(time = 0:10, group = factor(0:1))


# Rstanarm Generation of Posterior Predictions
interval_rstanarm <- (predictive_interval(mod_rstanarm, newdata = newx, re.form = NA, prob = .95)) 
rstan_posterior_predictions <- rstanarm::posterior_predict(mod_rstanarm, newdata = newx, re.form = NA)
stan_median <- cbind(apply(rstan_posterior_predictions, 2, median))
interval_rstanarm <- cbind(stan_median, interval_rstanarm)

newxsub <- expand.grid(time = 0:10, group = factor(0:1), subject = 1:100)

# Brms version of Posterior Predictions
interval_brms <- fitted(mod_brms, newdata = newx, re_formula = NA) 
interval_brms_null <- predict(mod_brms, newdata = newx, re_formula = NULL) 


multi$brmspred <- predict(mod_brms)[,1]

# Lmer version of posterio predictions
lmer_predict <- predict(mod_lme4, newdata = newx, re.form = NA) 


# Bootstrapping functions from https://cran.r-project.org/web/packages/merTools/vignettes/Using_predictInterval.html
mySumm <- function(.) {
  predict(., newdata=newx, re.form=NA)
}


sfun1 <- function(x) {
    simulate(x,newdata=newx,re.form=NA,
             allow.new.levels=TRUE)[[1]]
}


sumBoot <- function(merBoot) {
  return(
    data.frame(fit = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.5, na.rm=TRUE))),
               lwr = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.025, na.rm=TRUE))),
               upr = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.975, na.rm=TRUE)))
    )
  )
}

boot3 <- lme4::bootMer(mod_lme4, mySumm, nsim=250, use.u=FALSE, type = 'parametric')
interval_lme4 <- sumBoot(boot3)
interval_lme4 <- cbind(interval_lme4, newx)

interval_brms <- data.frame(cbind(interval_brms, newx)) %>%
  mutate(group = factor(group))

interval_rstanarm <- data.frame(cbind(interval_rstanarm, newx)) %>%
  mutate(group = factor(group))

ggplot(multi, aes(x = time, y = outcome)) +
  geom_jitter(height = 0, width = .2, alpha = .5, size = .5) +
  stat_summary(fun.data = 'mean_cl_boot') +
  geom_line(aes(group = subject, color = group)) +
  geom_point(data = interval_brms, aes(x = time, y = Estimate, color = group), size = 4) +
  geom_ribbon(data = interval_brms, aes(x = time, y = Estimate, ymin = X2.5.ile, ymax = X97.5.ile, fill = group), alpha = .5)


ggplot(multi, aes(x = time, y = outcome)) +
  #geom_line(data = interval_brms, aes(x = time, y = Estimate, color = group), size = 1) +
  #geom_ribbon(data = interval_brms, aes(x = time, y = Estimate, ymin = X2.5.ile, ymax = X97.5.ile, fill = group), alpha = .5) +
  geom_line(data = multi, aes(x = time, y = brmspred, color = factor(subject))) +
  theme(legend.position = 'none')
```


```{r}

langSim <- read.table('http://coltekin.net/cagri/R/data/bilingual.txt', header = T)

# Make similar models with lme4, rstanarm, brms
mod_rstanarm <- stan_glmer(data = langSim, mlu ~ age + (1|subj))
mod_lme4 <- lmer(data = langSim, mlu ~ age + (1|subj))
mod_brms <- brm(data = langSim, mlu ~ age + (1|subj))
summary(mod_lme4)
summary(mod_brms)

# Generate a 'grid' of new data values
newdata <- expand.grid(age = c('preschool', 'firstgrade', 'secondgrade'))

# Rstanarm Generation of Posterior Predictions
interval_rstanarm <- (predictive_interval(mod_rstanarm, newdata = newdata, re.form = NA, prob = .95)) 
rstan_posterior_predictions <- rstanarm::posterior_predict(mod_rstanarm, newdata = newdata, re.form = NA)
stan_median <- cbind(apply(rstan_posterior_predictions,2, median))
interval_rstanarm <- cbind(stan_median, interval_rstanarm)

# Brms version of Posterior Predictions
interval_brms <- predict(mod_brms, newdata = newdata, re_formula = NA) 

# Lmer version of posterio predictions
interval_lme4 <- predict(mod_lme4, newdata = newdata, re.form = NA) 

mySumm <- function(.) {
  predict(., newdata=newdata, re.form=NA)
}

sumBoot <- function(merBoot) {
  return(
    data.frame(fit = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.5, na.rm=TRUE))),
               lwr = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.025, na.rm=TRUE))),
               upr = apply(merBoot$t, 2, function(x) as.numeric(quantile(x, probs=.975, na.rm=TRUE)))
    )
  )
}

interval_lme4 <- cbind(interval_lme4, newdata)
interval_brms <- cbind(interval_brms, newdata)

ggplot(interval_lme4, aes(x = age, y = fit, ymin = lwr, ymax = upr)) +
  geom_point() + 
  geom_linerange()

ggplot(interval_brms, aes(x = age, y = Estimate, ymin = `2.5%ile`, ymax = `97.5%ile`)) +
  geom_point() + 
  geom_linerange()
  


boot3 <- lme4::bootMer(mod_lme4, mySumm, nsim=250, use.u=FALSE, type = 'parametric')
View(boot3$t)

interval_lme4 <- sumBoot(boot3)

PI.time <- system.time(
  PI <- predictInterval(merMod = mod_lme4, newdata = newdata,
                        level = 0.95, n.sims = 1000,
                        stat = "median")
)

# using predictInterval


ggplot(langSim, aes(x = age, y = mlu, color = factor(subj))) + 
  geom_line(aes(group = subj)) +
  geom_point() +
  stat_summary(fun.data = 'mean_cl_boot', color = 'black')

```


```{r}
require(effects)
plot(effect('time:group', mod_lme4))
theme_set(theme_bw())

marginal_effects(mod_brms, method = 'predict', re_formula= NA)

effect_time <- as.data.frame(effect('time:group', mod_lme4, confint(level = .95), xlevels = list(time = 0:10, group = c('0','1'))))
effect_group <- as.data.frame(effect('group', mod_lme4, confint(level = .95), xlevels = list(time = 0:10, group = c('0','1'))))
```

Put 'em al together
```{r}


```
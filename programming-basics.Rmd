---
title: "CU Psych R Tutorial - Programming Basics"
author: "Monica Thieu"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## First off

R is a programming language designed for statistical computing and production of statistical graphics. In other words, **R is for doing stats with code.** With R, you have a lot of power over your stats (statistical power? ha ha ha), once you get a hang on the code part. Before we get to the **stats** part, though, we'll spend a little bit of time on the **code** part.

To be able to make full flexible use of R, we're going to learn some basics of programming. Essentially, you'll learn what your computer hears when you speak to it using R, and strategies for how to tell your computer to do certain things you will often want it to do. We'll also touch on some best practices for code writing: how to write code that's efficient both for your computer (to run) and for humans (to read).

## Defining things

### Variables

At its base, our goal with programming is to tell a computer to take some input information, do something with it, and give us the output. A **variable** is how we'll store that information in a way that the computer can operate on. A variable has two parts: a **name** and a **value**. A variable's name allows us to specify which piece of information we want the computer to operate on, and its value specifies the information to be operated on itself.

Below, I'll initialize a variable named `x`, and assign it the value 1. **Initializing** is the programming term for creating a new variable that didn't previously exist.

```{r}
# In plain English, this translates to "Initialize the variable 'x' and assign to it the value 1" or, more succinctly, "Let 'x' take the value of 1".
# The <- (left-facing arrow) operator is what you'll use to assign values to variables. Values can be numbers, like here, or they can be much more complex pieces of information (which we'll get to in a bit).
# You'll specify your inputs on the RIGHT side (shaft) of the arrow, and your desired output location on the LEFT side (head) of the arrow.
# If you use the framing "Let [left side] take the value of [right side]" you can remember how to assign values to variables. It's like taking the value on the right, and pushing it along the direction of the arrow into the variable name on the left.
x <- 1
```

Now, the computer is holding onto this information, and I can access it and do what I wish with it. This information is being held onto in R's **environment,** or a chunk of computer memory that R uses to store information. When you are working on stored variables in R, this is where they live. It's kind of like R's working memory. Just as in psychology, it's *not* the same as long-term memory--storing variables in the environment is *not* equivalent to saving them to your computer as you would a document or other file. You can ONLY work on your R variables in R.

If I want to know what the value of `x` is, I can ask the computer to output the value of `x` to console. The **console** is where the magic happens: the window where you type commands and run them by pressing Enter. **Commands** are any instruction you give to your computer via your programming language. Typically, one complete command is one line of code.

If your command has an output associated with it, the output will appear below your command in the console. Use outputs to quickly check what the values of variables are.

```{r}
# Typing the name of a variable, without anything else, and running that command will cause R to output the value of that variable. This is also called "printing" the variable's value to console output.
# Notice that there's no arrow in this command!
x
```

In fact, if you type *any* command with **no arrow** R will print the results of your command to console output.

```{r}
# This time, we'll do a little bit of calculating. See again that there's no arrow in the command, and that the result of my addition has printed to console.
2 + 2
```

Now, we see the output of `2 + 2`, but that information isn't held onto anywhere. If you want to store the results of a command for later, you'll need to set a variable equal to those results. Let's save the results of `2 + 2` into the variable `x`. Since `x` has already been initialized, we're going to be writing OVER the old value of x with new information.

```{r}
# "Assign to x the result of 2 + 2"
x <- 2 + 2
```

Now, just to be sure, let's check the value of x by printing it to console:

```{r}
x
```

Great! Now that the results are being stored in the variable `x`, we can do stuff to those results. For example, a little bit more calculating:

```{r}
x * 2
```

Now let's do that calculation again, and this time we'll save the results of this new command into a variable.

```{r}
# Initialize the variable "y"
y <- x * 2
```

Again, let's check that the value of `y` is what we'd expect by printing to console.

```{r}
y
```

We don't have to create a new variable every time we want to store some information. As you saw, you can write over the existing value of a variable by setting the variable equal to something else. You can even write over the existing value of a variable by doing a calculation on that variable itself:

```{r}
# Read this as "Assign to NEW y the OLD value of y divided by 2"
# Whenever you're setting a variable equal to some function of itself, ALL of the commands and calculations will be run using the OLD value of the variable, and it will only be reassigned after the WHOLE command is run.
y <- y / 2
```

And now let's check the new value of `y` in console output:

```{r}
y
```


#### Best practices: naming variables

In each section, we'll touch on best practices. Best practices for programming encompasses the conventions you should follow in writing your code to make it readable to your collaborators, and most importantly, future you! These will be interspersed in their relevant locations, and summarized again for you at the end.

With regards to variables, you can make the name of a variable almost whatever you want, within reason. A variable name can legally contain:

- letters (upper or lowercase, R is case sensitive!)
- numbers
- period (.) and underscore (_)

R (and basically all programming languages) require variable names to START with a LETTER. (Try initializing a variable name starting with a number and see what happens.) Other allowed characters can be anywhere in the variable name except for first.

Beyond this, here are some recommendations we strongly urge you to follow as well when naming variables:

- Name variables informatively, not arbitrarily! The name of a variable should tell you something about what information it contains. `raw.data` is better than `d`.
- Use a period to separate words in multi-word variable names.
- Name variables succinctly, but informatively. Abbreviations are okay if they are standard throughout your code. `max.val` is okay instead of `maximum.value`.
- When in doubt, use lowercase letters.

This whole time, we've been using console output to see the values of variables.

Cool! Let's review now:

- A **variable** stores some **value** under a **name** that you can use to refer to that value
- Variables are stored in the **environment** (like R's working memory)
- You can do operations on variables (calculator-type and otherwise) by referring to them by name in commands
- You can print the value of a variable (or the result of any command) by typing it with no `<-`
- You can set the value of a variable to the result of a command
  - You can set the value of a variable to the result of a command involving another variable
  - You can set the *new* value of a variable to the result of a command involving the *old* value of that same variable
  
### Functions

Before we get further, let's take a brief moment to go over the anatomy of a **function.** If you consider that previously, we learned that our goal with programming is to tell a computer to take some input information, do something with it, and give us the output, a **function** is the *do something with it* part of this sentence. (We just learned that a variable holds that *input info* and also can hold the *output info.*)

You'll use a great many functions to DO STUFF to your variables in R. Let's go over the pieces of a function so you know how to use one.

Below is an example (fake) function call. This function takes the inputs `input1` and `input2`, does the function `function()` to those inputs, and returns an output which can be stored in a variable. Here are the relevant pieces:

`output <- function(argument1 = input1, argument2 = input2)`

- `function()`: This is the function that will DO SOMETHING to your inputs.
  Whenever you are referencing a function by name, you should always write it with the two parentheses () after the function name so people know you're referring to a function and not a variable.
  The name of a function will tell you something about what a function does. You can/should look it up if you're not sure though!
- `argument1`, `argument2`, etc: These are **arguments** to a function--this is the information that a function *expects* and *is prepared to operate on*.
  The name of an argument will tell you something what an argument represents and how it should be formatted. (More on this later)
- `input1`, `input2`, etc: These are variables that you created that will actually get fed into your function. This is the information that will actually get operated on. These can be data that live in your environment, or these can be settings (like switches and knobs, if your function was an actual machine) that are turned to a specific value.
- `output`: This is the variable that will hold your output information.
  As you can see, we are ASSIGNING the value that's output from `function()` to the variable `output` using the `<-` left-facing arrow operator. Just like before with printing variable values to console, if you run a function without assigning its output to a variable, the output will print to console (so you can read it) but it will not be stored anywhere (so you can't perform any further operations on that output).

#### Best practices: Using & getting help with functions

Most times, if you're having a problem in R, it's because a function that you want to use is not doing the thing that you want it to do to your data. Here's a few best practices for using functions, so that when (not if... trust me) you have a problem with a function, you can resolve your problem with a minimum of hair-pulling.

- Spell out the names of your arguments in all function commands.
  R understands that `function(input1, input2)` means the same thing as `function(argument1 = input1, argument2 = input2)`. Functions have expected arguments listed in a particular order, and if you don't explicitly name the argument, it will assume you are specifying your input variables in the default argument order. If you want to look back at a function call you used in the past, though, if you don't remember what arguments a function takes, or what order they're expected, *you will get confused!* Always spell out all argument names so that you (or someone else) can look back later and know what you were trying to do.
- When you need help...
  - Search the documentation first
    In RStudio, you can use the "Help" tab in the lower right corner of your window to search for the help page for a function you're having trouble with. You can type the name of your problem function into the search bar and pull up the help page! You can also use the function `help()` in console to pull up the same info. `help()` takes the name of your function as an argument. For example, if I want the help page for the `mean()` function (take arithmetic mean of data), I would run `help(topic = "mean")` in console.
  - Google it (for real)
    Googling the answer can save you LOTS of time if the docs don't help first. I usually type something like "R [function name] won't [do the thing I am trying to do]", substituting my problem function and my desired operation into the search term.
  - Ask a human
    When asking a human for help via text (email etc.), always refer to your problem function name as `function()` with the parentheses () after the function name. This helps your colleague know that you are referring to a function, and not a variable.

### Data types

Thus far, we've created a couple variables and set them equal to a number (either explicitly, or as the result of a calculation). That's not the only type of information R can store, though. R can store all sorts of stuff! What kinds of stuff? Let's take a look.

The different formats of information R understands are called **data types.** Broadly, the type of a piece of data specifies what kind of information it holds, and what kinds of operations might be done on that data. There are different things you would want to do with different pieces of data, and data types allow a programming language to know the sorts of things you want to use a piece of information for.

#### Numeric data

We've been working with numbers thus far, and you'll likely continue to work with numbers in your R travels. (I mean, what else are you gonna do stats on?) The **numeric** data type specifies that your variable is a number, and allows R to do mathematical operations on it.

```{r}
# I'm going to reassign x here to a number of my own choosing. Not necessarily my favorite number, just what popped into my head.
x <- 16

# Here's the basic arithmetic operations R understands.  

x + 0.5
# R understands PEMDAS! As should you.
3 * (x - 7)
x / 4
x^2
```

```{r}
# Bonus arithmetic!

# What is this!? %% is the "modulo" operator. This operator says "attempt to divide the second value into the first value and output the remainder." So 16 / 8 leaves remainder 0, but 16 / 7 leaves remainder 2 (aka 16 - 14). You might be wondering when on earth this would ever be useful. Just trust us on this one!
x %% 8
x %% 7
# Another goofy operator! %/% is a cousin to modulo: integer divison. This operator says "attempt to divide the second value into the first value and output the integer result without the remainder." So 16 %/% 8 <- 2 remainder 0, and 16 %/% 7 <- 2 remainder 2, so the remainder info is discarded and these two commands both output 2.
x %/% 8
x %/% 7
```


#### Logical data

A special case of numeric data is **logical** data, which is essentially binary (0 or 1) numeric data. R will let you represent binary numeric data as TRUE/FALSE, where 0 means FALSE and 1 means TRUE. You can do everything you can do with numeric data on logical data, like:

```{r}
# this behaves like 1 + 5
TRUE + 5
```

Logical data can also do stuff that numeric data can't do. For example, a function can take an argument like  `function(data <- my.variable, do.this <- TRUE)`, where the argument `do.this` specifies a sort of on/off switch to control what operations you want `function()` to do on `my.variable`.

#### Character data

Another type of data you'll likely need to work with is word-based data. The **character** data type specifies that your variable contains word-based information, and allows R to perform language-y operations on a variable. One piece of character data is called a **string.**

```{r}
this.string <- "words"
```

In psychology research, you might use string data in the following contexts:

- Coding participant IDs
- Indicating levels of independent variable conditions (e.g. "Control" vs "Manipulation")
- Actual textual data (e.g. a participant's written response to a question)

For example, a couple string-specific operations you can do on character data:

```{r}
# If you check the docs, you'll see that the function toupper() expects an argument called x, where x is any character data. We won't specify the arg name here--e.g. toupper(x = this.string)--because base functions like this, that really only take one argument, are self-explanatory enough that you can look back later and know what you were doing. You should name args for more complex functions though! 
# toupper() returns the same character data that was input, but in all caps. This, and its companion function tolower(), can be really handy when you need to standardize text data that comes in different cases.
toupper(this.string)
```

```{r}
# nchar() also expects an argument called x (I know, x is not an informative variable name. This only happens with the really basic functions, I promise!). 
# It returns the character count (INCLUDING SPACES AND SPECIAL CHARACTERS) of a character variable. So here, knowing that the input variable is "words", what do we expect the output character count to be?
nchar(this.string)
```

**R is not the place to be doing intense textual analysis!** But R CAN handle your run-of-the-mill text labeling/processing needs.

#### Vectors

So now we know that R understands a few different basic data types--numeric, logical, and character. We've operated on single chunks of information thus far--one number or one string. 99.9% of the time, though, your data will not be comprised of one piece of information. In these cases, you'll be using **vectors,** which are sequences of values stored together in one variable.

For example:

```{r}
this.vector <- 1
```

Right now, the variable `this.vector` is storing ONE piece of information. But if I do this:

```{r}
# The function c() will become a very, very close friend of yours. This is the CONCATENATION function. In the context of R, concatenation means "combining multiple distinct values into one vector". (chaining things together, per the lay definition)
# You'll see that I didn't name any arguments that passed into c(). I just typed the numbers right in there, separated with commas. c() doesn't actually take named arguments--it can take any type of information that is concatenate-able.
this.vector <- c(1, 2, 3)
this.vector
```

`this.vector` now is storing the THREE values: 1, 2, and 3. Each of these values in the vector is called an **element.** We will spend more time later looking at all the fantastic things you can do with vectors. A couple examples here:

```{r}
# You can do vectorized math: R understands this as "take ALL the values in this.vector, and add 7 to each of them individually."
this.vector + 7
```

```{r}
# You can do summarizing operations using the values in a vector as a group:
# Again, see that some basic functions like sum() don't take named arguments. In these cases, it's okay because reading the function is pretty self-explanatory re: what your intention was in writing the function.

sum(this.vector)
```

```{r}
# You can do vector-to-vector math:
# WHENEVER you are doing mathematical operations with vectors, R will ASSUME you want these vectorized (e.g. do the operation using the first element of both vectors, then the second element of both, etc)
# This is critical to remember in R. For the types of operations you'll likely be doing, this is the "common sense" way of operating on things, but not all programming languages behave this way, so this doesn't necessarily generalize.
this.other.vector <- c(10, 20, 30)
this.vector + this.other.vector
```

One type of vector you might need to deal with is a series of numbers increasing by 1. You can use the `:` colon operator to create a vector of numbers spanning any range, increasing by 1. For example, if you need to number a series of 15 observations 1 through 15, you might want to create a vector containing the numbers 1, 2, 3 ... 15 to label those observations. See below:

```{r}
# Use the colon between the start and the end numbers!
yet.another.vector <- c(1:15)
yet.another.vector
```

```{r}
# You can use c() to create a vector containing colon-generated sequences along with other numbers too.
# We'll reassign yet.another.vector below. Say I want to make a vector holding numbers from 1 to 25, but I want to skip 16 and 18. I can do that this way:
yet.another.vector <- c(1:15, 17, 19:25)
yet.another.vector
```


##### Indexing into vectors
If you want to extract specific elements from a vector, you can do that too, by typing the "address" of the element you want into hard brackets [] after hte name of the vector. The "address" of an element in a vector is called its **index.** A vector has only one dimension (length), so the index of an element is a single number specifying its location in the vector.

If you are coming from other languages, note that **indexing in R starts at 1, not 0.** So to get the first element of a vector, you use the index 1, and so on. It's more common-sensey for the usual user, but this is a deviation from how most programming languages handle indexing.

```{r}
# Return the first element of this.vector to console
this.vector[1]
```

```{r}
# Return the second element of this.other.vector to console
this.other.vector[2]
```

```{r}
# What if you want to index multiple elements of a vector at once? You sure can. How? With...
# VECTOR-CEPTION!
# You can index into a vector using a VECTOR of indices, and return a vector of all indexed values.
# Below, I am using c() to create a vector containing the values 1 through 5, and feeding that into the indexing brackets, to call the values at all requested indices.
# See that the output to console is also a vector. This time it's a shorter vector, since I only requested a subset of the values of the original.
yet.another.vector[c(1:5)]
```

```{r}
# Or if you want to request all values of a vector EXCEPT certain values, you can do that too.
# Use the minus sign in front of an index value to indicate to R that you want NOT that value.
# Below, I am asking for ALL values of this.vector EXCEPT the 3rd one.
this.vector[-3]
```

```{r}
# You can also use the minus except syntax for multiple indices, per below.
# Notice that the below syntax, "all values of this.other.vector EXCEPT the first AND second one," is equivalent to saying "only the first value of this.other.vector ."
# Since there are multiple different ways to index desired values of a vector (specify the ones you want, or minus-specify the ones you don't want), you can choose the way that requires the least amount of typing.
this.other.vector[-c(1, 2)]
```

##### Numeric vectors

Vectors come in different flavors based on the type of data stored in the elements of the vector. All the vectors we've just been looking at are **numeric vectors**--vectors with numbers in them. You can do math and stats on the numbers in a vector. You can index subsets of those numbers and do stats on those. You can combine vectors into longer vectors and do more stats on those. **The numeric vector is the core of research data in R!**

##### Character vectors

But, numeric vectors aren't the ONLY super cool fun vector you'll need. **Character vectors**, vectors containing strings as their elements, are handy as well. You create this the same way as you create a numeric vector...

```{r}
# with our best friend c() !
# See how the output that prints to console looks similar / different to the output of numeric vectors.
this.char.vector <- c("jackfruit", "coconut", "lychee", "rambutan")
this.char.vector
```

You can index into a character vector just like you would with a numeric vector.

```{r}
# Is this prounced lee-chee or lye-chee? Real question.
this.char.vector[3]
```

You can also apply string functions like the ones we saw before to character vectors.

```{r}
# Using a string function on a character vector will return another vector, with the function applied to each of the original elements individually.
# if you think about it, previously we were just doing all these operations on vectors of length 1. So the vector operation is the broad case, and a vector of length 1 is a special case.
toupper(this.char.vector)
```

It's important to remember that a character vector containing a series of strings is NOT the same as ONE string containing the same "words." For example,

```{r}
these.words <- "jackfruit coconut lychee rambutan"
# nchar() here returns 33, because that's the number of characters in the whole ONE string.
nchar(these.words)
```

The above is not the same as our original character vector!

```{r}
# meanwhile here, nchar() returns a value for the character count of EACH ELEMENT SEPARATELY.
nchar(this.char.vector)
```

Vectors can contain as many elements as your heart desires, but **all of the elements of a single vector must be the same data type.** This assumption/requirement is what gives vectors their magical efficient powers. "But what if I need to have a vector with different data types together?" Soon, friends. We'll get there!

#### Factor data

#### Data frames

Ahhhh, my favorite of the data structures. This is where the magic happens!
A **data frame** is a 2D array-like rectangular structure with rows and columns, where each column is a vector, and each row corresponds to the element at the same index of each column vector. Sounds like... real data! 

Let's look at a sample data frame.

```{r}
# Do not mind the functions I am calling here to create this fake data. If you'd like to look them up, though, you can check them out in the docs!
this.df <- data.frame(subjects = sprintf(fmt = "sub%02d", c(1:20)),
                      age = sample(x = c(18:35), size = 20, replace = TRUE),
                      condition = c(rep(x = "control", times = 10), rep(x = "manipulation", times = 10)),
                      score = rnorm(n = 20, mean = 75, sd = 10),
                      stringsAsFactors = FALSE)
this.df
```

Because dataframes must be rectangular, all column vectors of a dataframe must be the same length, as must all rows. If you think about the structure of a dataset, this makes sense. If each row corresponds to the info from one subject, for example, and each column corresponds to some metric you're collecting data on, each subject should have an observation of every metric (each row is the same length). And each column should contain every subject's data (each column is the same length).

You'll see that when dealing with dataframes, using print-to-console to visually inspect your data starts to get unwieldy. Large data frames are quite cumbersome to print to console and examine. If you're in RStudio, however, you can make use of TECHNOLOGY!

```{r}
# Use View() WITH A CAPITAL V! to pop a dataframe up in your viewer window (likely in the top left of RStudio).
# You can use View() with most data types--vectors, matrices, whatever. But View() is truly best for visually inspecting dataframes.
# If you like the visual inspection capabilities of Excel (and I do, I will admit), View() should do you just fine. Note that the viewer window is just that--a viewer! NOT an editor. So you can ONLY change values using commands to console. (This is better for data safety. No more accidentally changing data because you clicked in an Excel cell you weren't supposed to!)
# Please be aware that in data frames with very many columns, View() will not show you all the columns! There are other ways of looking for what you want in that case.
View(this.df)
```

Remember that each column of a dataframe is a vector. Hence, you can do all of the vector things to a dataframe column. 

How do we index values of a dataframe? There are a few ways; each will be useful in some situations but not others.

```{r}
# The first way is by using the hard brackets [] that we used to index into vectors before. Remember that a dataframe is a collection of vectors!
# Consider that a dataframe has two dimensions: length and width. This means that we have up to TWO locations to specify to index values in a dataframe: which row and which column. (A simple vector can be considered as just ONE column, such that indexing into the vector requires only the row index.)

# To extract one specific value, use the following syntax:
# data.frame[ROW, COLUMN]
# Below, we are indexing the value in the 8th row and 1st column of this.df
# It is easy to get mixed up as to whether the order is [row, column] or [column, row]. Frankly, if I'm not sure, I will just try putting the indices in both orders and seeing which one actually gives me the value I was looking for.

# Note that when indexing ONE value, the data type of my output is the pure data type of that one value (numeric or character).
this.df[8,1]
```

```{r}
# Just as before, when we used vectors of indices to index multiple elements of a vector, we can index multiple elements of a dataframe. Observe:

this.df[c(8:10), c(1:3)]
```

#### Non-data data

Non-data data? What is this business? Why would we bother with this?

It's important to be able to have a data type to mark non-data as a placeholder in vectors, especially in vectors within dataframes. When (not if) you collect a dataset where some subjects have missing data for some reason, you need to be able to use a non-data indicator to mark elements of a dataframe as empty without having to totally delete that subject's row.

#### Lists

## Logical & relational operators

## Conditional statements

## Loops

## Summary of best practices

## Attributions

Language and layout inspired by [Trevor Page's Programming 101](https://howtoprogramwithjava.com/programming-101-the-5-basic-concepts-of-any-programming-language/).
Basic info about the language referenced from [the official R Language Definition docs](https://cran.r-project.org/doc/manuals/r-release/R-lang.html).
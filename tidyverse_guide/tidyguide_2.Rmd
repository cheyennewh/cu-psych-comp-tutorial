---
title: "Tidy walkthrough, part 2"
author: "Monica Thieu"
date: "July 13, 2018"
output:
  html_document:
    theme: "journal"
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
```


# Go home

**First of all,** you can click [here](https://cu-psych-r-users.github.io/cu-psych-r-tutorial/) to return to the CU psychology tutorials page.

# Goals for this vignette

Hello (again)! This is a continuation of our tour through base tidyverse. Our goals are the same as before:

* Demonstrate (what I think are) key first-level features of the tidyverse
* Illustrate psychology use cases for tidyverse functions
* Hopefully convince you to join the cult of tidy

This time, we'll be moving ahead to some more complex use cases utilizing some more advanced programming tactics. I hope to show you how the tidyverse makes these things a little smoother!

Again, please remember that for more exhaustive documentation you can visit the online reference pages for your packae of interest, and for more in-depth self-teaching, please refer to [R for Data Science online textbook](http://r4ds.had.co.nz/) by Garrett Grolemund and Hadley Wickham.

# Quick cheat-list of key functions from various pkgs

* `purrr`
    + all the `map()` functions: like `apply()` but tidy
* `broom`
    + `tidy()` etc

# Initializing fake data

We'll use a simulated dataset for this vignette, so you don't need to worry about any dependencies involving datasets you don't have access to while you're following along.

If you have `tidyverse` loaded, all this code should run if you try to run it in your R console.

If you're coming from part 1 of our tidyverse tour, this is the exact same simulated raw data as before.

```{r}
# 20 fake subjects, 50 fake trials per subject

# Will simulate the person-level variables FIRST,
# then expand to simulate the trial-level variables
raw <- tibble(id = 1L:20L,
              age = sample(18L:35L, size = 20, replace = TRUE),
              # assuming binary gender for the purposes of this simulation
              gender = sample(c("male", "female"), size = 20, replace = TRUE)) %>%
  # simulating some "questionnaire" scores; person-level
  mutate(q_1 = rnorm(n = n(), mean = 30, sd = 10),
              q_2 = rnorm(n = n(), mean = 30, sd = 10),
              q_3 = rnorm(n = n(), mean = 30, sd = 10)) %>%
  # slice() subsets rows by position; you can use it to repeat rows by repeating position indices
  slice(rep(1:n(), each = 50)) %>%
  # We'll get to this in a bit--this causes every "group"
  # aka every set of rows with the same value for "id", to behave as an independent df
  group_by(id) %>%
  # I just want to have a column for "trial order", I like those in my task data
  mutate(trial_num = 1:n(),
         # Each subject sees half OLD and half NEW trials in this recognition memory task
         is_old = rep(0L:1L, times = n()/2),
         # I'm shuffling the order of "old" and "new" trials in my fake memory task
         is_old = sample(is_old),
         # This will generate binary "old"/"new" responses corresponding roughly to a d' of 1
         # yep, everyone has the same d' today
         response = if_else(is_old == 1,
                            rbinom(n = n(), size = 1, prob = 0.7),
                            rbinom(n = n(), size = 1, prob = 0.3)),
         rt = rnorm(n = n(), mean = 3, sd = 1.5)) %>%
  ungroup()
```

# Working with nested dfs

Nearly all of the tidyverse features we'll be working through in this vignette rely on two key features of R to make their magic happen: **list-columns** and **flexible vectorizing functions.** These are features that you may very well encounter explicitly in casual R usage, so we'll take a bit of time to familiarize ourselves with these concepts before we jump all the way in.

## A brief (re)view of lists

Your usual vector, be it character, numeric, or logical, is an _atomic vector_--this means that every element in the vector is required to be _the same data type._ A **list** is also a vector, but it's not bound to be atomic. The different elements of a list _do not have to be the same data type._ They don't even all have to be length 1!

If you're familiar with data types in Matlab, a list is very similar to a Matlab struct array. Both are objects that contain multiple elements that aren't bound to be the same type, or length 1.

# Vectorizing to the high heavens

`purrr::map()` goes here? compare to `apply` family of functions in base R

## Vectorizing: t's like a for loop, but not

## Tidy vectorizing

# Working with model objects en masse

## Fitting a whole lotta models

## Extracting model coefficients

# Plotting data

If there are any `tidyverse` packages you were acquainted with before you first jumped into the tidy sea, you likely already knew about `ggplot2`. For this reason, and because Paul Bloom's fantastic `ggplot2` vignettes cover plenty of ground (TODO: link), we won't be getting much into plotting here.

The one thing, though, that I'd like to show you is how I like to use the pipe to pre-process dfs before plotting. Want to plot just a subset of a df? Or maybe re-label some factor levels for the plot, but not save those factor levels back into the main df?


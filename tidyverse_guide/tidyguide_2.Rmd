---
title: "Tidy walkthrough, part 2"
author: "Monica Thieu"
date: "July 13, 2018"
output:
  html_document:
    theme: "journal"
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
```


# Go home

**First of all,** you can click [here](https://cu-psych-r-users.github.io/cu-psych-r-tutorial/) to return to the CU psychology tutorials page.

# Goals for this vignette

Hello (again)! This is a continuation of our tour through base tidyverse. Our goals are the same as before:

* Demonstrate (what I think are) key first-level features of the tidyverse
* Illustrate psychology use cases for tidyverse functions
* Hopefully convince you to join the cult of tidy

This time, we'll be moving ahead to some more complex use cases utilizing some more advanced programming tactics. I hope to show you how the tidyverse makes these things a little smoother!

Again, please remember that for more exhaustive documentation you can visit the online reference pages for your packae of interest, and for more in-depth self-teaching, please refer to [R for Data Science online textbook](http://r4ds.had.co.nz/) by Garrett Grolemund and Hadley Wickham.

# Quick cheat-list of key functions from various pkgs

* `purrr`
    + all the `map()` functions: like `apply()` but tidy
* `broom`
    + `tidy()` etc

# Initializing fake data

We'll use a simulated dataset for this vignette, so you don't need to worry about any dependencies involving datasets you don't have access to while you're following along.

If you have `tidyverse` loaded, all this code should run if you try to run it in your R console.

If you're coming from part 1 of our tidyverse tour, this is the exact same simulated raw data as before.

```{r}
# 20 fake subjects, 50 fake trials per subject

# Will simulate the person-level variables FIRST,
# then expand to simulate the trial-level variables
raw <- tibble(id = 1L:20L,
              age = sample(18L:35L, size = 20, replace = TRUE),
              # assuming binary gender for the purposes of this simulation
              gender = sample(c("male", "female"), size = 20, replace = TRUE)) %>%
  # simulating some "questionnaire" scores; person-level
  mutate(q_1 = rnorm(n = n(), mean = 30, sd = 10),
              q_2 = rnorm(n = n(), mean = 30, sd = 10),
              q_3 = rnorm(n = n(), mean = 30, sd = 10)) %>%
  # slice() subsets rows by position; you can use it to repeat rows by repeating position indices
  slice(rep(1:n(), each = 50)) %>%
  # We'll get to this in a bit--this causes every "group"
  # aka every set of rows with the same value for "id", to behave as an independent df
  group_by(id) %>%
  # I just want to have a column for "trial order", I like those in my task data
  mutate(trial_num = 1:n(),
         # Each subject sees half OLD and half NEW trials in this recognition memory task
         is_old = rep(0L:1L, times = n()/2),
         # I'm shuffling the order of "old" and "new" trials in my fake memory task
         is_old = sample(is_old),
         # This will generate binary "old"/"new" responses corresponding roughly to a d' of 1
         # yep, everyone has the same d' today
         response = if_else(is_old == 1,
                            rbinom(n = n(), size = 1, prob = 0.7),
                            rbinom(n = n(), size = 1, prob = 0.3)),
         rt = rnorm(n = n(), mean = 3, sd = 1.5)) %>%
  ungroup()
```

# Nested dfs

Nearly all of the tidyverse features we'll be working through in this vignette rely on two key features of R to make their magic happen: **list-columns** and **flexible vectorizing functions.** These are features that you may very well encounter explicitly in casual R usage, so we'll take a bit of time to familiarize ourselves with these concepts before we jump all the way in.

## A brief (re)view of lists

Your usual vector, be it character, numeric, or logical, is an _atomic vector_--this means that every element in the vector is required to be _the same data type._ A **list** is also a vector, but it's not bound to be atomic. The different elements of a list _do not have to be the same data type._ They don't even all have to be length 1!

If you're familiar with data types in Matlab, a list is very similar to a Matlab struct array. Both are objects that contain multiple elements that aren't bound to be the same type, or length 1.

While you might initialize an atomic vector using `c()`, you have to use `list()` to initialize list vectors.

```{r}
mylist <- list(1,
               "one",
               c(1, 11, 111))

mylist
```

Notice how R shows you the bracket indexing of the list elements above. There are _two_ ways to bracket index list vectors, with single brackets `[]` and double brackets `[[]]`.

_Single_-bracket indexing a list vector **always returns another list object.**

```{r}
mylist[1]
```

```{r}
mylist[2:3]
```

See above that when you print single-bracket indexed lists to console, you still get console output that shows you each list element under double-bracketed indices.

```{r}
typeof(mylist[2:3])
```

More explicitly, you can see that single-bracket indexing a list will return an object of list type.

Meanwhile, _double_-bracket indexing a list vector **returns the object _stored inside_ that list field.**

```{r}
mylist[[2]]
```

```{r}
mylist[[3]]
```

Above, you actually get the object stored _inside_ the list at the relevant element. This is probably what you're expecting when you index a list--to unlist or "unwrap" the element on the inside you wish to access.

```{r}
typeof(mylist[[3]])
```

Just making sure that it is in fact the type of the element stored inside, and no longer list type.

Notice that you can return an indexed list object _of any length_ when you single-bracket index, but double-bracket indexing to extract individual list elements only lets you access _one at a time!_

A feature of lists that can be very useful is that list elements can have names. You can create a named list object by naming list elements when you specify them:

```{r}
mylist <- list(first = 1,
               second = "one",
               third = c(1, 11, 111))

mylist
```

When a list has named elements, printing the list to console will show you the names of the elements. Handy!

The best thing about named list elements is that you can use those names to access list elements!

```{r}
mylist["first"]
```
```{r}
mylist[c("second", "third")]
```


```{r}
mylist[["first"]]
```

Again, single-bracket indexing continues to return a list (this time, a named list containing the elements you indexed), and allows you to index multiple elements at once by feeding in a character vector of names. Double-bracket indexing, meanwhile, unwraps the element you're indexing.

You can also index named lists with the dollar sign `$` operator! Seem familiar?

```{r}
mylist$third
```

This is the same way you index df columns! In fact, somewhere deep down, a dataframe/tibble is a very special list, where each list element is required to be a vector of the same length. Isn't that cool?

That's the basics you need to know about lists, summarized here just in case:

* it's a vector, basically
* it contains different elements that are not bound to be the same type, and can be vectors themselves
* Single-bracket indexing returns a list, while double-bracket indexing unwraps the element
* elements can have names, which allows indexing by name using brackets or `$`

## Lists as df columns

A df is composed of columns, each of which is a vector of identical length. But nobody ever said the columns of a df all have to be atomic vectors! A df column can be a list vector, where each element of said list-column can contain objects of different data types and lengths.

This becomes a little easier to wrap your head around if we explicitly look at a df with list-columns in it. Below, we'll take a look at the `starwars` df, which is a toy dataset about Star Wars characters that comes standard with `dplyr`.

```{r}
starwars
```

In this df, each row is a "subject" (a character from the movies). Currently, this data is "tidy": each row is a unique observation (subject in this case), and each column is a distinct variable giving information about that observation.

Because this object is a tibble (makes sense since it comes with `dplyr`), we can inspect the nice print output to see the types of the different columns. We can see that the first few columns are atomic vectors, either numeric like `height` and `mass` or character like `homeworld`. But check out the last three columns...

```{r}
starwars %>%
  select(name, films, vehicles, starships)
```

The last three columns are list type! This makes sense based on the content we might expect to be contained within each column. For example, if each row is one character, but one character appears in multiple movies, you might expect that character's value in the `films` column to contain a vector with one element for each movie that character was in. In this way, a list-column allows you to store multiple observations per subject wrapped up in such a way that the main df still has one row per subject, but you retain the observation-level data because you haven't actually collapsed across any variables.

(You're probably familiar with fully long-form data, where each observation has its own row, and then grouping variables like subject are repeated for all observations that belong to the same subject. We will learn about the relationship between dfs containing list-columns and fully long-form dfs later!)

Now, for list-columns, instead of actually printing the content of the vector, tibble output gives us a blurb about the object contained inside of each list element. To inspect the contents of a list-column, we have to index into the list-column using one of the techniques we reviewed above.

We can index by position, which corresponds to row numbers, using single-bracket indexing to return another, shorter list:

```{r}
# These should be Luke's starships that he piloted at some point in the series
# since we saw earlier that he's the first row of the df
starwars$starships[1]
```

Or double-bracket indexing, which allows us to actually access the object contained within:

```{r}
starwars$starships[[1]]
```

We can also use logical indexing to access list-column elements based on values in other columns.

```{r}
# This is good when you don't necessarily know the row number of what you're looking for
starwars$starships[starwars$name == "Han Solo"]
```

 Note that _logical indexing only works with single-bracket indexing._ If you want to unwrap the object contained within, you have to index twice like below:
 
```{r}
starwars$starships[starwars$name == "Han Solo"][[1]]
```
 
This works because single-bracket indexing always returns another list, and you can then double-bracket index into THAT list. It's a lot of brackets, but it does follow a pattern!

### A df with a list-column still behaves like a df, mostly

If your df contains a list-column, you can do most things with that df that you might do with a fully atomic list-free df. You can:

* subset by column using `select()`
* reshape your df using `gather()` and `spread()`

There are a couple respects in which list-columns are limited, though. Most of these involve the fact that R makes fewer assumptions about the content of lists (since elements are not bound to be the same type/length 1), and so for your own safety the tidyverse prevents you from doing some things that might yield unexpected results:

* you cannot directly `filter()` or `distinct()` a df by a list-column, but you can do these things to a df containing list-columns by an atomic column
* you cannot `group_by()` a df by a list-column, but you can `group_by()` atomic columns in a df containing list-columns

What about using `mutate()` to create/modify list-columns? You can do this, but it requires special vectorizing functions like `purrr::map()` that we will cover later. Stay tuned!

### df-ception: df list-columns that contain other dfs

Okay, so now that you've seen list-columns that contain different atomic vectors, it's time to get list-crazy! A list really can contain _basically anything_ in each of its elements. This means that a list can contain a whole df inside of one (or more) of its list elements.

When would you want a df that contains other dfs? Well, remember that list-columns are typically useful to contain multiple observations of information that pertain to one subject/group/etc while allowing your df to take a one-row-per-subject/group structure.

You usually won't be creating dfs with df-containing list-columns from scratch. More likely, you'll start with a fully long df, and condense the repeated measures data by folding it into a list-column using `tidyr::nest()`. Let's try it with the `starwars` df, by creating a df that has one row per species x homeworld, and a list-column containing a df for all of the characters of a particular species/homeworld grouping.

```{r}
starwars_by_species_home <- starwars %>%
  group_by(species, homeworld) %>%
  nest(.key = "characters")

starwars_by_species_home
```

We've done two things here:

1. We grouped our df using `group_by()` to tell `nest()` what the grouping-level variables are
2. We folded all the observations into a separate column using `nest()`, using the `.key` argument to specify the name of that new column

`nest()` is what you'll use to create nested dfs, or dfs with columns containing other dfs. `nest()` takes every column that isn't a grouping variable, and folds all of the observations in each group into their own df in the new list-column. All the data we had before is inside this new list-column. Let's look inside one of these sub-dfs to be sure:

```{r}
starwars_by_species_home$characters[[1]]
```

In our new nested df, the first row contains all Star Wars characters who are humans from Tatooine. Thus, if we look inside the df stored in the first element of the `characters` list-column using double-bracket indexing, we see all of the original character-level observations belonging to this group. Notice that inside this sub-df, the columns `species` and `homeworld` are absent. This is because these columns are already present in the main df, as the grouping variables.

You can `nest()` with as many or as few grouping variables as you'd like--anything that you can `group_by()` you can `nest()` along.

If you have a nested df that you would like to unnest, and return to fully long form, you can do that using `tidyr::unnest()`. As you might guess, `unnest()` essentially does the exact opposite of `nest()`-- it takes list-columns and unfolds them back out to be one row per observation instead of one row per group.

```{r}
starwars_by_species_home %>%
  unnest(characters)
```

There we go, this should be the same df as before! As shown above, `unnest()` takes the names of columns to be unnested as arguments. I like to always specify the column(s) I'd like to unnest for maximum readability, so it's obvious to future you/other collaborators exactly what you're nesting.

You'll see that the rows have been re-ordered according to the previous nested grouping, so keep this in mind if you're expecting rows to be in a particular order (you may need to re-order your df using `arrange()` after unnesting).

#### What are nested dfs useful for?

For the most part, straightforward data manipulation operations are easier to do on fully long dfs than they are on nested dfs, for reasons we'll get to soon. You won't need to use a nested df all the time, and that's okay! Nested dfs are really great for allowing you to do summarizing and modeling operations _alongside your observation-level data, without discarding it._ We'll be learning about this below, so don't forget about nested dfs because they are coming back!

# Vectorizing to the high heavens

Next, we'll review vectorizing: this is a feature of R that you probably use all the time and don't even know it! We'll learn a little more about what vectorized functions do and how you can vectorize any function you wish.

To read 

`purrr::map()` goes here? compare to `apply` family of functions in base R

## Vectorizing: it's like a for loop, but not

## Tidy vectorizing

### Operating on list-columns using map()

# Working with model objects en masse

## Fitting a whole lotta models

## Extracting model coefficients

# Plotting data

If there are any `tidyverse` packages you were acquainted with before you first jumped into the tidy sea, you likely already knew about `ggplot2`. For this reason, and because Paul Bloom's fantastic `ggplot2` vignettes cover plenty of ground (TODO: link), we won't be getting much into plotting here.

The one thing, though, that I'd like to show you is how I like to use the pipe to pre-process dfs before plotting. Want to plot just a subset of a df? Or maybe re-label some factor levels for the plot, but not save those factor levels back into the main df?


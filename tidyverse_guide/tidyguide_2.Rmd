---
title: "Tidy walkthrough, part 2"
author: "Monica Thieu"
date: "July 13, 2018"
output:
  html_document:
    theme: "journal"
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
```


# Go home

**First of all,** you can click [here](https://cu-psych-r-users.github.io/cu-psych-r-tutorial/) to return to the CU psychology tutorials page.

# Goals for this vignette

Hello (again)! This is a continuation of our tour through base tidyverse. Our goals are the same as before:

* Demonstrate (what I think are) key first-level features of the tidyverse
* Illustrate psychology use cases for tidyverse functions
* Hopefully convince you to join the cult of tidy

This time, we'll be moving ahead to some more complex use cases utilizing some more advanced programming tactics. I hope to show you how the tidyverse makes these things a little smoother!

Again, please remember that for more exhaustive documentation you can visit the online reference pages for your packae of interest, and for more in-depth self-teaching, please refer to [R for Data Science online textbook](http://r4ds.had.co.nz/) by Garrett Grolemund and Hadley Wickham.

# Quick cheat-list of key functions from various pkgs

* `purrr`
    + all the `map()` functions: like `apply()` but tidy
* `broom`
    + `tidy()` etc

# Initializing fake data

We'll use a simulated dataset for this vignette, so you don't need to worry about any dependencies involving datasets you don't have access to while you're following along.

If you have `tidyverse` loaded, all this code should run if you try to run it in your R console.

If you're coming from part 1 of our tidyverse tour, this is the exact same simulated raw data as before.

```{r}
# 20 fake subjects, 50 fake trials per subject

# Will simulate the person-level variables FIRST,
# then expand to simulate the trial-level variables
raw <- tibble(id = 1L:20L,
              age = sample(18L:35L, size = 20, replace = TRUE),
              # assuming binary gender for the purposes of this simulation
              gender = sample(c("male", "female"), size = 20, replace = TRUE)) %>%
  # simulating some "questionnaire" scores; person-level
  mutate(q_1 = rnorm(n = n(), mean = 30, sd = 10),
              q_2 = rnorm(n = n(), mean = 30, sd = 10),
              q_3 = rnorm(n = n(), mean = 30, sd = 10)) %>%
  # slice() subsets rows by position; you can use it to repeat rows by repeating position indices
  slice(rep(1:n(), each = 50)) %>%
  # We'll get to this in a bit--this causes every "group"
  # aka every set of rows with the same value for "id", to behave as an independent df
  group_by(id) %>%
  # I just want to have a column for "trial order", I like those in my task data
  mutate(trial_num = 1:n(),
         # Each subject sees half OLD and half NEW trials in this recognition memory task
         is_old = rep(0L:1L, times = n()/2),
         # I'm shuffling the order of "old" and "new" trials in my fake memory task
         is_old = sample(is_old),
         # This will generate binary "old"/"new" responses corresponding roughly to a d' of 1
         # yep, everyone has the same d' today
         response = if_else(is_old == 1,
                            rbinom(n = n(), size = 1, prob = 0.7),
                            rbinom(n = n(), size = 1, prob = 0.3)),
         rt = rnorm(n = n(), mean = 3, sd = 1.5)) %>%
  ungroup()
```

# Working with nested dfs

Nearly all of the tidyverse features we'll be working through in this vignette rely on two key features of R to make their magic happen: **list-columns** and **flexible vectorizing functions.** These are features that you may very well encounter explicitly in casual R usage, so we'll take a bit of time to familiarize ourselves with these concepts before we jump all the way in.

## A brief (re)view of lists

Your usual vector, be it character, numeric, or logical, is an _atomic vector_--this means that every element in the vector is required to be _the same data type._ A **list** is also a vector, but it's not bound to be atomic. The different elements of a list _do not have to be the same data type._ They don't even all have to be length 1!

If you're familiar with data types in Matlab, a list is very similar to a Matlab struct array. Both are objects that contain multiple elements that aren't bound to be the same type, or length 1.

While you might initialize an atomic vector using `c()`, you have to use `list()` to initialize list vectors.

```{r}
mylist <- list(1,
               "one",
               c(1, 11, 111))

mylist
```

Notice how R shows you the bracket indexing of the list elements above. There are _two_ ways to bracket index list vectors, with single brackets `[]` and double brackets `[[]]`.

_Single_-bracket indexing a list vector **always returns another list object.**

```{r}
mylist[1]
```

```{r}
mylist[2:3]
```

See above that when you print single-bracket indexed lists to console, you still get console output that shows you each list element under double-bracketed indices.

```{r}
typeof(mylist[2:3])
```

More explicitly, you can see that single-bracket indexing a list will return an object of list type.

Meanwhile, _double_-bracket indexing a list vector **returns the object _stored inside_ that list field.**

```{r}
mylist[[2]]
```

```{r}
mylist[[3]]
```

Above, you actually get the object stored _inside_ the list at the relevant element. This is probably what you're expecting when you index a list--to unlist or "unwrap" the element on the inside you wish to access.

```{r}
typeof(mylist[[3]])
```

Just making sure that it is in fact the type of the element stored inside, and no longer list type.

Notice that you can return an indexed list object _of any length_ when you single-bracket index, but double-bracket indexing to extract individual list elements only lets you access _one at a time!_

A feature of lists that can be very useful is that list elements can have names. You can create a named list object by naming list elements when you specify them:

```{r}
mylist <- list(first = 1,
               second = "one",
               third = c(1, 11, 111))

mylist
```

When a list has named elements, printing the list to console will show you the names of the elements. Handy!

The best thing about named list elements is that you can use those names to access list elements!

```{r}
mylist["first"]
```
```{r}
mylist[c("second", "third")]
```


```{r}
mylist[["first"]]
```

Again, single-bracket indexing continues to return a list (this time, a named list containing the elements you indexed), and allows you to index multiple elements at once by feeding in a character vector of names. Double-bracket indexing, meanwhile, unwraps the element you're indexing.

You can also index named lists with the dollar sign `$` operator! Seem familiar?

```{r}
mylist$third
```

This is the same way you index df columns! In fact, somewhere deep down, a dataframe/tibble is a very special list, where each list element is required to be a vector of the same length. Isn't that cool?

That's the basics you need to know about lists, summarized here just in case:

* it's a vector, basically
* it contains different elements that are not bound to be the same type, and can be vectors themselves
* Single-bracket indexing returns a list, while double-bracket indexing unwraps the element
* elements can have names, which allows indexing by name using brackets or `$`

## Lists as df columns

A df is composed of columns, each of which is a vector of identical length. But nobody ever said the columns of a df all have to be atomic vectors!

# Vectorizing to the high heavens

`purrr::map()` goes here? compare to `apply` family of functions in base R

## Vectorizing: t's like a for loop, but not

## Tidy vectorizing

# Working with model objects en masse

## Fitting a whole lotta models

## Extracting model coefficients

# Plotting data

If there are any `tidyverse` packages you were acquainted with before you first jumped into the tidy sea, you likely already knew about `ggplot2`. For this reason, and because Paul Bloom's fantastic `ggplot2` vignettes cover plenty of ground (TODO: link), we won't be getting much into plotting here.

The one thing, though, that I'd like to show you is how I like to use the pipe to pre-process dfs before plotting. Want to plot just a subset of a df? Or maybe re-label some factor levels for the plot, but not save those factor levels back into the main df?

